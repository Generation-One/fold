# Fold v2 - Architecture Overview

## Full File Indexing Pipeline

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                           FILE SOURCES                                       │
├─────────────────────────────────────────────────────────────────────────────┤
│  GitHub Webhook  │  GitLab Webhook  │  Polling Loop  │  Manual Trigger      │
│       (push)     │      (push)      │   (5 min)      │   (API/MCP)          │
└────────┬─────────┴────────┬─────────┴───────┬────────┴──────────┬───────────┘
         │                  │                 │                   │
         └──────────────────┴─────────────────┴───────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         JOB QUEUE (SQLite)                                   │
├─────────────────────────────────────────────────────────────────────────────┤
│  Job Types:                                                                  │
│  • index_repo     - Index specific files from push                          │
│  • reindex_repo   - Full repository reindex                                 │
│  • process_webhook - Handle webhook events                                  │
│  • sync_metadata  - Sync to remote (deprecated)                             │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                       JOB WORKER (job_worker.rs)                             │
├─────────────────────────────────────────────────────────────────────────────┤
│  1. Claims job atomically (prevents duplicate processing)                   │
│  2. Checks LLM/embedding providers are available                            │
│  3. Ensures local clone exists (clone or pull)                              │
│  4. Routes to appropriate handler                                           │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                      INDEXER SERVICE (indexer.rs)                            │
├─────────────────────────────────────────────────────────────────────────────┤
│  For each file:                                                              │
│                                                                              │
│  1. Read file content from local clone                                       │
│  2. Skip if: empty, >100KB, non-code, excluded pattern                      │
│  3. Calculate SHA256 hash → memory_id (first 16 chars)                      │
│  4. Check cache: skip if hash unchanged                                      │
│  5. Check fold/: skip if fold/a/b/hash.md exists                            │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         LLM SUMMARISATION                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│  llm.summarize_code(content, file_path, language)                           │
│                                                                              │
│  Returns:                                                                    │
│  • title        - Human-readable title (max 100 chars)                       │
│  • summary      - Comprehensive 2-4 sentence description                     │
│  • keywords     - Function names, class names, key terms (max 15)           │
│  • tags         - Categories (auth, database, api, etc.) (max 6)            │
│  • exports      - Public functions, classes, types                          │
│  • dependencies - Imported modules/packages                                  │
│  • created_date - Earliest date found in file (from comments, headers)      │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                     MEMORY SERVICE (memory.rs)                               │
├─────────────────────────────────────────────────────────────────────────────┤
│  memory_service.add(project_id, project_slug, create, auto_metadata)        │
│                                                                              │
│  1. Auto-analyse content (if auto_metadata=true)                            │
│     → Extract keywords, context (3-5 sentences), tags via LLM              │
│     → Context covers: purpose, role in system, responsibilities,           │
│       architectural patterns, relationships, design decisions               │
│                                                                              │
│  2. Create Memory object                                                     │
│     → id, project_id, type, source, title, keywords, tags, context          │
│                                                                              │
│  3. Write to fold/ directory                                                 │
│     → fold_storage.write_memory(project_root, memory, content)              │
│     → Creates fold/a/b/aBcD123.md with YAML frontmatter                     │
│     → Includes original_date if extracted from file                         │
│                                                                              │
│  4. Insert metadata into SQLite                                              │
│     → memories table (id, project_id, title, keywords, tags, etc.)          │
│                                                                              │
│  5. Generate embedding                                                       │
│     → embeddings.embed_single(content + context + keywords + tags)          │
│                                                                              │
│  6. Store in Qdrant                                                          │
│     → qdrant.upsert(project_slug, memory_id, embedding, payload)            │
│                                                                              │
│  7. Process memory evolution (A-MEM)                                         │
│     → Find 5 nearest neighbours in Qdrant                                    │
│     → Ask LLM: should we link/evolve?                                       │
│     → Create links in memory_links table                                     │
│     → Update neighbour metadata if needed                                    │
│     → Update fold file with [[wiki-style]] links to related memories        │
└─────────────────────────────────────────────────────────────────────────────┘
                                    │
                                    ▼
┌─────────────────────────────────────────────────────────────────────────────┐
│                         AUTO-COMMIT (git.rs)                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│  If project.auto_commit_enabled() and files were indexed:                   │
│                                                                              │
│  git_service.auto_commit_fold(project_root, message)                        │
│  → git add fold/                                                             │
│  → git commit -m "fold: Index N files from project"                         │
└─────────────────────────────────────────────────────────────────────────────┘

---

## Storage Locations

| What | Where | Purpose |
|------|-------|---------|
| **Content** | `fold/a/b/hash.md` | Markdown with YAML frontmatter |
| **Metadata** | SQLite `memories` table | id, title, keywords, tags, context |
| **Vectors** | Qdrant collection | Semantic search embeddings |
| **Links** | SQLite `memory_links` table | Related/DependsOn/References |

---

## Example fold/ File

```markdown
---
id: aBcD123456789abc
title: Authentication Service
author: system
tags:
  - auth
  - typescript
  - security
file_path: src/auth/service.ts
language: typescript
memory_type: codebase
original_date: "2024-03-15"
created_at: 2026-02-03T10:30:00Z
updated_at: 2026-02-03T10:30:00Z
related_to:
  - f0123456789abcde
  - 9a8b7c6d5e4f3g2h
---

This module implements JWT-based authentication with refresh tokens. It serves as the core
authentication layer for the application, handling both user login flows and API token
validation. The service uses RS256 asymmetric signing for enhanced security and implements
refresh token rotation to prevent token theft. Key responsibilities include token generation,
validation with expiry checking, and secure session management.

## Key Components
- AuthService - Main authentication service class
- validateToken() - Token validation with expiry check
- refreshToken() - Refresh token rotation

## Dependencies
- jsonwebtoken, bcrypt

---

## Related

- [[f/0/f0123456789abcde.md|f0123456789abcde]]
- [[9/a/9a8b7c6d5e4f3g2h.md|9a8b7c6d5e4f3g2h]]
```

### Frontmatter Fields

| Field | Description |
|-------|-------------|
| `id` | Content hash (first 16 chars of SHA256) |
| `title` | Human-readable title |
| `author` | Who created this memory |
| `tags` | Category tags for classification |
| `file_path` | Original source file path (if from code) |
| `language` | Programming language |
| `memory_type` | Type: codebase, session, spec, decision, etc. |
| `original_date` | Creation date extracted from file content (if found) |
| `created_at` | When this memory was indexed |
| `updated_at` | Last modification time |
| `related_to` | IDs of linked memories |

### Wiki-Style Links

Related memories are linked using wiki-style markdown links at the bottom of each file:
```
[[a/b/hash.md|hash]]
```

This format works with Obsidian and other markdown editors that support wiki links.

---

## Features Removed in v2

### 1. 8 Memory Types → 1 Unified Type
Previously had: `Codebase`, `Session`, `Spec`, `Decision`, `Commit`, `PullRequest`, `General`, `Manual`
Now just: unified `Memory` with `source` field (`File`, `Agent`, `Git`)

### 2. ACT-R Decay Algorithm
- Strength-based memory decay over time
- Retrieval tracking (access count, last accessed)
- Decay-weighted search scoring
- **Status**: Re-enabled in search

### 3. Attachments System
- File uploads attached to memories
- Deleted: `srv/src/db/attachments.rs`, `srv/src/api/attachments.rs`

### 4. Team Status Features
- Team member status tracking
- Deleted: `srv/src/api/team.rs`

### 5. AI Session Tracking
- Session notes, AI conversation history
- Deleted: `srv/src/api/sessions.rs`

### 6. Metadata Repository Sync
- Syncing memories to a separate metadata git repo
- Deleted: `srv/src/services/meta_storage.rs`

### 7. Complex Graph Traversal
- Detailed graph query API
- Replaced with simpler "context" API

### 8. Commit/PR Specific Memories
- Memories tied to specific commits or PRs
- Now just generic memories with optional `file_path`

### 9. Usage/Access Tracking Tables
- Detailed analytics on memory access patterns

### 10. Workspaces
- Multi-workspace support

---

## Features Kept

- **OIDC Authentication** - Login via Zitadel, Google, GitHub
- **File Source Providers** - GitHub, GitLab, Local filesystem
- **Webhooks** - Real-time updates from Git providers
- **Vector Embeddings** - Gemini/OpenAI embeddings
- **Qdrant** - Vector similarity search
- **LLM Summarisation** - Code summaries via Gemini/OpenAI
- **Memory Links** - Simplified 4 link types (Related, References, DependsOn, Modifies)
- **MCP Interface** - Claude Code integration
- **Job Queue** - Background indexing with retry/recovery
- **Decay-weighted Search** - ACT-R inspired memory strength

---

## Key Files

### Services
- `srv/src/services/memory.rs` - Agentic memory with A-MEM evolution
- `srv/src/services/indexer.rs` - File indexing pipeline
- `srv/src/services/fold_storage.rs` - Hash-based fold/ storage
- `srv/src/services/job_worker.rs` - Background job processing
- `srv/src/services/decay.rs` - ACT-R decay algorithm
- `srv/src/services/git.rs` - Auto-commit and sync

### Database
- `srv/schema.sql` - Simplified schema (9 tables)
- `srv/src/db/memories.rs` - Memory CRUD
- `srv/src/db/links.rs` - Memory links

### API
- `srv/src/api/memories.rs` - Memory endpoints
- `srv/src/api/mcp.rs` - MCP tools

---

## Database Schema (Simplified)

```sql
-- Core tables
projects          -- Project metadata
repositories      -- Git repo connections
memories          -- Memory metadata (content in fold/)
memory_links      -- Relationships between memories
jobs              -- Background job queue

-- Auth tables
users             -- OIDC users
sessions          -- User sessions
api_tokens        -- API authentication
oauth_states      -- OIDC flow state
auth_providers    -- Dynamic OIDC config
```

---

## Search Flow (with Decay)

```
Query
  │
  ▼
Generate embedding
  │
  ▼
Qdrant vector search (top N)
  │
  ▼
For each result:
  │
  ├─ Get memory from SQLite
  │
  ├─ Calculate decay strength:
  │   strength = recency_factor × access_boost
  │   - recency_factor decays over time (half-life)
  │   - access_boost from retrieval_count
  │
  ├─ Blend scores:
  │   combined = (1 - weight) × semantic + weight × strength
  │
  └─ Update last_accessed, retrieval_count
  │
  ▼
Sort by combined score
  │
  ▼
Return results
```
