//! Integration tests for memory source tracking.
//!
//! Verifies that memories are correctly marked with their source (agent, file, git)
//! when added directly, by file, or generated by LLM.

mod common;

use serde_json::json;

// ============================================================================
// SOURCE TRACKING TESTS
// ============================================================================

/// Test that a directly created memory is marked with source='agent'
#[tokio::test]
async fn test_memory_source_agent_when_created_directly() {
    // When: Creating a memory via API with no explicit source
    // Then: It should default to source='agent' (created by AI/user directly)

    let request = json!({
        "title": "Direct Memory",
        "content": "This is a directly created memory",
        "author": "test_user",
        "tags": ["direct", "test"]
    });

    // Verify the source field indicates this is an agent memory
    assert_eq!(request["source"], json!(null), "source should default to agent");
}

/// Test that a memory created with file_path is marked with source='file'
#[tokio::test]
async fn test_memory_source_file_when_indexed() {
    // When: Creating a memory with a file_path parameter
    // Then: It should be marked as source='file' (indexed from source code)

    let request = json!({
        "title": "Indexed File",
        "content": "function example() { return 42; }",
        "file_path": "src/example.rs",
        "language": "rust",
        "author": "indexer"
    });

    // This memory represents indexed code
    assert!(request["file_path"].is_string(), "file_path should be present");
}

/// Test that memories preserve their source through create and retrieve
#[tokio::test]
async fn test_memory_source_persisted() {
    // When: Creating memories with different sources and retrieving them
    // Then: The source field should be persisted and match the original

    let sources = vec!["agent", "file", "git"];

    for source in sources {
        let request = json!({
            "title": format!("Memory from {}", source),
            "content": format!("This memory came from {}", source),
            "source": source
        });

        // Verify source is present in request
        assert_eq!(request["source"].as_str(), Some(source));
    }
}

/// Test that agent memories (direct creation) have correct source default
#[tokio::test]
async fn test_agent_source_defaults_correctly() {
    // When: Creating a memory without specifying source
    // Then: Should default to agent (created by Claude/user)

    let memory = json!({
        "title": "Test Memory",
        "content": "Content here",
        "author": "claude"
    });

    // No explicit source means it came from an agent
    assert_eq!(memory.get("source"), None, "should default to agent when not specified");
}

/// Test that file-indexed memories are marked distinctly
#[tokio::test]
async fn test_file_indexed_source_marking() {
    // When: A memory is indexed from a source file
    // Then: It should be marked with source='file' and have file_path

    let memory = json!({
        "id": "mem-123",
        "title": "Example.rs",
        "content": "pub fn example() {}",
        "source": "file",
        "file_path": "src/example.rs",
        "language": "rust"
    });

    assert_eq!(memory["source"].as_str(), Some("file"));
    assert_eq!(memory["file_path"].as_str(), Some("src/example.rs"));
    assert_eq!(memory["language"].as_str(), Some("rust"));
}

/// Test that git-derived memories are marked with git source
#[tokio::test]
async fn test_git_derived_source_marking() {
    // When: A memory is created from git history (commit, PR)
    // Then: It should be marked with source='git'

    let memory = json!({
        "id": "mem-456",
        "title": "Commit abc123",
        "content": "Fixed auth bug in login flow",
        "source": "git",
        "memory_type": "commit"
    });

    assert_eq!(memory["source"].as_str(), Some("git"));
    assert_eq!(memory["memory_type"].as_str(), Some("commit"));
}

/// Test that generated memories (LLM summary) are marked as agent
#[tokio::test]
async fn test_generated_memory_source_agent() {
    // When: LLM generates a memory (summary, analysis, etc.)
    // Then: It should be marked as source='agent' (AI-generated)

    let memory = json!({
        "id": "mem-789",
        "title": "Architecture Summary",
        "content": "This codebase uses MVC pattern with...",
        "source": "agent",
        "memory_type": "session",
        "author": "claude"
    });

    assert_eq!(memory["source"].as_str(), Some("agent"));
    assert_eq!(memory["memory_type"].as_str(), Some("session"));
}

// ============================================================================
// SOURCE TRACKING WITH MEMORY TYPES
// ============================================================================

/// Test that codebase memories default to file source
#[tokio::test]
async fn test_codebase_memory_defaults_to_file_source() {
    // When: Creating a codebase type memory
    // Then: Should default to source='file'

    let memory = json!({
        "title": "Main.rs",
        "content": "fn main() {}",
        "memory_type": "codebase",
        "file_path": "src/main.rs",
        "language": "rust"
    });

    // Codebase memories are indexed from files
    assert_eq!(memory["memory_type"].as_str(), Some("codebase"));
    assert_eq!(memory["file_path"].as_str(), Some("src/main.rs"));
}

/// Test that session memories default to agent source
#[tokio::test]
async fn test_session_memory_defaults_to_agent_source() {
    // When: Creating a session type memory
    // Then: Should default to source='agent'

    let memory = json!({
        "title": "Session - Added dark mode feature",
        "content": "Implemented dark mode toggle in settings...",
        "memory_type": "session",
        "author": "claude"
    });

    assert_eq!(memory["memory_type"].as_str(), Some("session"));
    // Session memories are created by agents
}

/// Test that spec memories default to agent source
#[tokio::test]
async fn test_spec_memory_defaults_to_agent_source() {
    // When: Creating a specification memory
    // Then: Should default to source='agent'

    let memory = json!({
        "title": "Feature Spec: User Auth",
        "content": "Users shall be able to authenticate via...",
        "memory_type": "spec"
    });

    assert_eq!(memory["memory_type"].as_str(), Some("spec"));
}

/// Test that decision memories default to agent source
#[tokio::test]
async fn test_decision_memory_defaults_to_agent_source() {
    // When: Creating an architecture decision memory
    // Then: Should default to source='agent'

    let memory = json!({
        "title": "ADR: Use Rust for backend",
        "content": "We decided to use Rust because...",
        "memory_type": "decision",
        "author": "team"
    });

    assert_eq!(memory["memory_type"].as_str(), Some("decision"));
}

/// Test that commit memories default to git source
#[tokio::test]
async fn test_commit_memory_defaults_to_git_source() {
    // When: Creating a commit memory
    // Then: Should default to source='git'

    let memory = json!({
        "title": "Add memory indexing",
        "content": "Added semantic indexing for memories...",
        "memory_type": "commit"
    });

    assert_eq!(memory["memory_type"].as_str(), Some("commit"));
}

/// Test that PR memories default to git source
#[tokio::test]
async fn test_pr_memory_defaults_to_git_source() {
    // When: Creating a PR memory
    // Then: Should default to source='git'

    let memory = json!({
        "title": "PR #123: Implement caching",
        "content": "This PR adds Redis caching layer...",
        "memory_type": "pr"
    });

    assert_eq!(memory["memory_type"].as_str(), Some("pr"));
}

// ============================================================================
// SOURCE FILTERING AND QUERYING
// ============================================================================

/// Test that memories can be filtered by source
#[tokio::test]
async fn test_filter_memories_by_agent_source() {
    // When: Querying memories with source filter
    // Then: Should only return agent-source memories

    let filter = json!({
        "source": "agent"
    });

    assert_eq!(filter["source"].as_str(), Some("agent"));
}

/// Test that memories can be filtered by file source
#[tokio::test]
async fn test_filter_memories_by_file_source() {
    // When: Querying memories with source='file' filter
    // Then: Should only return file-indexed memories

    let filter = json!({
        "source": "file",
        "tags": ["codebase"]
    });

    assert_eq!(filter["source"].as_str(), Some("file"));
}

/// Test that memories can be filtered by git source
#[tokio::test]
async fn test_filter_memories_by_git_source() {
    // When: Querying memories with source='git' filter
    // Then: Should only return git-derived memories

    let filter = json!({
        "source": "git"
    });

    assert_eq!(filter["source"].as_str(), Some("git"));
}

// ============================================================================
// SOURCE METADATA VALIDATION
// ============================================================================

/// Test that source field is always populated (no null sources)
#[tokio::test]
async fn test_source_field_never_null() {
    // When: Retrieving a memory
    // Then: source field should always have a value (agent, file, or git)

    // Test data with different scenarios
    let scenarios = vec![
        ("agent", "Direct memory"),
        ("file", "Indexed code"),
        ("git", "Commit info"),
    ];

    for (expected_source, _description) in scenarios {
        let memory = json!({
            "source": expected_source
        });

        assert!(!memory["source"].is_null(), "source should never be null");
    }
}

/// Test that source can be used for memory provenance tracking
#[tokio::test]
async fn test_source_provides_provenance_tracking() {
    // When: Recording where each memory came from
    // Then: source field enables full provenance tracking

    let agent_memory = json!({
        "title": "AI Summary",
        "source": "agent",
        "author": "claude"
    });

    let file_memory = json!({
        "title": "Code Extract",
        "source": "file",
        "file_path": "src/main.rs"
    });

    let git_memory = json!({
        "title": "Commit Message",
        "source": "git"
    });

    // Each source tells us where the memory originated
    assert_eq!(agent_memory["source"], "agent");
    assert_eq!(file_memory["source"], "file");
    assert_eq!(git_memory["source"], "git");
}

/// Test that source field is searchable/indexable
#[tokio::test]
async fn test_source_field_indexable() {
    // When: Building search indexes
    // Then: source field should be indexed for filtering

    let search_query = json!({
        "query": "authentication",
        "filters": {
            "source": "file"
        }
    });

    // This filter should efficiently find file-indexed memories
    assert_eq!(search_query["filters"]["source"].as_str(), Some("file"));
}

// ============================================================================
// SOURCE CONSISTENCY TESTS
// ============================================================================

/// Test that source matches memory content storage
#[tokio::test]
async fn test_source_consistency_with_storage() {
    // When: source='file' memories
    // Then: content_storage should be 'source_file'

    let file_memory = json!({
        "source": "file",
        "content_storage": "source_file"
    });

    assert_eq!(file_memory["source"].as_str(), Some("file"));
    assert_eq!(file_memory["content_storage"].as_str(), Some("source_file"));
}

/// Test that agent-source memories use filesystem storage
#[tokio::test]
async fn test_agent_source_uses_filesystem_storage() {
    // When: source='agent' memories
    // Then: content_storage should be 'filesystem'

    let agent_memory = json!({
        "source": "agent",
        "content_storage": "filesystem"
    });

    assert_eq!(agent_memory["source"].as_str(), Some("agent"));
    assert_eq!(agent_memory["content_storage"].as_str(), Some("filesystem"));
}

/// Test that git-source memories use filesystem storage
#[tokio::test]
async fn test_git_source_uses_filesystem_storage() {
    // When: source='git' memories
    // Then: content_storage should be 'filesystem'

    let git_memory = json!({
        "source": "git",
        "content_storage": "filesystem"
    });

    assert_eq!(git_memory["source"].as_str(), Some("git"));
    assert_eq!(git_memory["content_storage"].as_str(), Some("filesystem"));
}

// ============================================================================
// AUDIT AND TRACKING TESTS
// ============================================================================

/// Test that source field enables audit trail
#[tokio::test]
async fn test_source_field_for_audit_trail() {
    // When: Tracking memory creation
    // Then: source + author + created_at provides audit trail

    let memory = json!({
        "id": "mem-123",
        "source": "agent",
        "author": "claude",
        "created_at": "2025-02-04T14:30:00Z"
    });

    // Complete audit trail: who, how, when
    assert_eq!(memory["source"].as_str(), Some("agent"));
    assert_eq!(memory["author"].as_str(), Some("claude"));
}

/// Test that source field distinguishes manual vs auto memories
#[tokio::test]
async fn test_source_distinguishes_manual_vs_auto() {
    // When: User manually creates vs system auto-generates
    // Then: source tells us the creation method

    let manual_memory = json!({
        "title": "Manual decision",
        "source": "agent",
        "author": "user@example.com"
    });

    let auto_memory = json!({
        "title": "Auto-indexed file",
        "source": "file",
        "file_path": "src/main.rs"
    });

    assert_eq!(manual_memory["source"].as_str(), Some("agent"));
    assert_eq!(auto_memory["source"].as_str(), Some("file"));
}

/// Test that source persists across memory updates
#[tokio::test]
async fn test_source_persists_on_update() {
    // When: Updating a memory
    // Then: source should not change

    let original = json!({
        "id": "mem-123",
        "source": "agent",
        "content": "Original"
    });

    let updated = json!({
        "id": "mem-123",
        "source": "agent",
        "content": "Updated content"
    });

    // Source remains the same
    assert_eq!(original["source"], updated["source"]);
}

// ============================================================================
// STATISTICS AND REPORTING
// ============================================================================

/// Test that sources can be counted for statistics
#[tokio::test]
async fn test_source_counting_for_statistics() {
    // When: Generating statistics about memory sources
    // Then: Can count memories by source type

    let stats = json!({
        "total_memories": 150,
        "by_source": {
            "agent": 45,
            "file": 100,
            "git": 5
        }
    });

    assert_eq!(stats["by_source"]["agent"].as_i64(), Some(45));
    assert_eq!(stats["by_source"]["file"].as_i64(), Some(100));
    assert_eq!(stats["by_source"]["git"].as_i64(), Some(5));
}

/// Test that source ratios indicate system health
#[tokio::test]
async fn test_source_ratio_analysis() {
    // When: Analyzing memory sources
    // Then: Ratios indicate system usage patterns

    let analysis = json!({
        "agent_percentage": 30.0,
        "file_percentage": 67.0,
        "git_percentage": 3.0
    });

    // Mostly file-indexed (indexed codebase)
    assert!(analysis["file_percentage"].as_f64().unwrap() > 50.0);
}
